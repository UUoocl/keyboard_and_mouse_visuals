<!DOCTYPE html>
<html lang="en">
<head>
    <title>Ext-Trigger_Fast Fluid Simulation</title>
    <style>
        body {
            margin: 0;
            background-color: #cf161600;
            color: #fff;
            font-family: Helvetica, Arial, sans-serif;
            overflow: hidden; /* disable scrolling / rubberband effect on mobile */
            height:100vh;
        }

        canvas {
            display: block;
            position: absolute;
            outline:0;
        }

        * {
            /* disable on touch highlights of html elements, especially on mobile! */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

    </style>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1">
    <meta itemprop="name" content="Ext-Trigger_Fast Fluid Simulation">
    <meta itemprop="description" content="made with cables">
    <meta itemprop="image" content="screenshot.png">
    <meta name="description" content="made with cables"/>

</head>
<body>
    <canvas id="glcanvas" width="100vw" height="100vh" tabindex="1"></canvas>

    <script src="lib/obs-ws.js"></script>
    <script src="js/obsConnect.js"></script>
    <script src="obs_webSocket_details/websocketDetails.js"></script>
    <!-- <script src="lib/SCRIPT_FOR_THIS_Page.js"></script> -->
  
    <script>
      let mousePosX = 0, mousePosY = 0;
      let displayXmin = 0;
      let displayXmax = 0;
      let displayYmin = 0;
      let displayYmax = 0;
      
      window.addEventListener("load", (event) => {
        //wait for obs to add the css variables
        setTimeout(()=>{
          displayXmin = Number(getComputedStyle(document.body).getPropertyValue('--display-x-min'));
          displayXmax = Number(getComputedStyle(document.body).getPropertyValue('--display-x-max'));
          displayYmin = Number(getComputedStyle(document.body).getPropertyValue('--display-y-min'));
          displayYmax = Number(getComputedStyle(document.body).getPropertyValue('--display-y-max'));
          console.log(`displayXmin: ${displayXmin}, displayXmax: ${displayXmax}, displayYmin: ${displayYmin}, displayYmax: ${displayYmax}`);
        }, 100);
      });

        obs.on("InputSettingsChanged", async function (event) {
            switch (event.inputName) {
                case 'MouseLocation':
                    const mousePosition = event.inputSettings.text.split(" ");
                    if (isMacOS()) {
                        // Perform macOS-specific mouse position adjustments
                        mousePositionMapped = await mapNumRange_MacOS(mousePosition, displayXmin, displayXmax, displayYmin, displayYmax, 0, 0, window.innerWidth, window.innerHeight)
                        // console.log(Math.round(Number(mousePositionMapped[0])), Math.round(Number(mousePositionMapped[1])));
                        mousePosX = Math.round(Number(mousePositionMapped[0]));
                        mousePosY = Math.round(Number(mousePositionMapped[1]));
                    } else {
                        // console.log("The user is not on macOS.");
                        // Perform actions for other operating systems
                        const mousePositionMapped = await mapNumRange(mousePosition, displayXmin, displayXmax, displayYmin, displayYmax, 0, 0, window.innerWidth, window.innerHeight)
                        // console.log(Number(mousePositionMapped[0]),Number(mousePositionMapped[1]));
                        mousePosX = Math.round(Number(mousePositionMapped[0]));
                        mousePosY = Math.round(Number(mousePositionMapped[1]));
                    }

                    //print mouse position to text source
                    obs.call("SetInputSettings", {
                        inputName: 'mouseDisplay2',
                        inputSettings: {
                            text: `${mousePosX} ${mousePosY}`,
                        }
                    });

                    if (mousePosition) {
                        // get the current value
                        const varMouseX = CABLES.patch.getVar("MouseInX");
                        const varMouseY = CABLES.patch.getVar("MouseInY");
                        const currentValueX = varMouseX.getValue();
                        const currentValueY = varMouseY.getValue();
                        console.log("currentValueX: ", currentValueX, "currentValueY: ", currentValueY);

                        //get previous value variables
                        const varPreviousMouseX = CABLES.patch.getVar("prevMousePosX");
                        const varPreviousMouseY = CABLES.patch.getVar("prevMousePosY");

                        //
                        const varMouseMoving = CABLES.patch.getVar("MouseMoving");
                        const varMouseDrag = CABLES.patch.getVar("MouseIsDragged");
                        varMouseMoving.setValue(1);
                        varMouseDrag.setValue(1);

                        // change the value
                        varMouseX.setValue(Number(mousePosX));
                        varMouseY.setValue(Number(mousePosY));
                        varPreviousMouseX.setValue(currentValueX);
                        varPreviousMouseY.setValue(currentValueY);
                        varMouseMoving.setValue(0);
                        varMouseDrag.setValue(1);
                    }
                    break;
                case 'hotkeyText':
                    //document.getElementById("obsws-keyboard").innerHTML = event.inputSettings.text
                    break;
                case 'view mode':
                    viewMode = event.inputSettings.text;
                    break;
                default:
                    break;
            }
        })


      function isMacOS() {
        return navigator.userAgent.indexOf('Mac OS X') !== -1;
      }

      async function mapNumRange(num, inMinX, inMaxX, inMinY, inMaxY, outMinX, outMinY, outMaxX, outMaxY){
        const mappedX = ((num[0] - inMinX) * (outMaxX - outMinX)) / (inMaxX - inMinX) + outMinX;
        const mappedY = (num[1] - inMinY) * (outMaxY - outMinY) / (inMaxY - inMinY) + outMinY;
        return [mappedX, mappedY];
      }
      
      async function mapNumRange_MacOS(num, inMinX, inMaxX, inMinY, inMaxY, outMinX, outMinY, outMaxX, outMaxY){
        const mappedX = (num[0] - inMinX) * (outMaxX - outMinX) / (inMaxX - inMinX) + outMinX;
        const mappedY = outMinY + (outMaxY - outMinY) * ((inMaxY - num[1]) / (inMaxY - inMinY));
        return [mappedX, mappedY];
      }
    </script>

    <script type="text/javascript"  src="patches/patch.js"></script>


    <script type="text/javascript">

        function showError(errId, errMsg)
        {
            // handle critical errors here if needed
        }

        function patchInitialized(patch)
        {
            // You can now access the patch object (patch), register variable watchers and so on
        }

        function patchFinishedLoading(patch)
        {
            // The patch is ready now, all assets have been loaded
        }

        document.addEventListener("CABLES.jsLoaded", function (event)
        {
            CABLES.patch = new CABLES.Patch({
                patch: CABLES.exportedPatch,
                "prefixAssetPath": "",
                "assetPath": "assets/",
                "jsPath": "patches/",
                "glCanvasId": "glcanvas",
                "glCanvasResizeToWindow": true,
                "onError": showError,
                "onPatchLoaded": patchInitialized,
                "onFinishedLoading": patchFinishedLoading,
                "canvas": {"alpha":true, "premultipliedAlpha":true } // make canvas transparent
            });
        });

        // disable rubberband effect on mobile devices
        document.getElementById('glcanvas').addEventListener('touchmove', (e)=>{ e.preventDefault(); }, false);
    </script>
</body>
</html>
