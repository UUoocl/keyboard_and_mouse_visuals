<!-- https://uuoocl.github.io/slides-studio/slides_studio_OBS_browser_source.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5 source control</title>
    <style>
         :root {
            --display-width: 0px;
            --left: 0px;
         }
    </style>
</head>
<body>
    <script src="lib/obs-ws.js"></script>
    <script src="js/obsConnect.js"></script>
    <script src="js/obsCollection.js"></script>
    <!-- <script src="lib/p5.js"></script> -->

    <script id="p5 canvas">
        let monitors;
        let sketchMonitors;
        let sourceBackgroundRectangle;
        let originalMouseX = 0, originalMouseY = 0;
        let mousePosX = 0, mousePosY = 0;
        let sketchMousePosX = 0, sketchMousePosY = 0;

        function setup() {
            createCanvas(500, 400);
            monitors = new Monitors();  
            // obsDisplays = new ObsDisplays();
            // monitors.updateOBS();
        }
        
        function draw() {
            background(220);
            
            fill(0, 0, 0);
            textSize(20);
            text(`Original x:${originalMouseX}, Original y:${originalMouseY}`, 0, 20);
            text(`Mapped x:${mousePosX}, Mapped y:${mousePosY}`, 0, 40);
            
            translate(50, 50)
            
            //scene Boundary 16:9. 1920x1080 scaled to 400x225 ~21%
            fill(255,0, 0)
            rect(monitors.viewport.x, monitors.viewport.y, monitors.viewport.width, monitors.viewport.height);
            text(`${monitors.viewport.left}`, 0, 100);
            text(`${monitors.viewport.right}`, 400, 100);
            text(`${monitors.viewport.top}`, 200, 0);
            text(`${monitors.viewport.bottom}`, 200, 220);
            
            //mouse position circle
            fill(0, 0, 255);
            // monitors.monitorsBoundary
            // ellipse(map(mousePosX, 0, 20, 20));
            sketchMousePosX = Math.round(map(mousePosX,monitors.boundary.minX, monitors.boundary.maxX, monitors.sketchBoundary.x, monitors.sketchBoundary.width + monitors.sketchBoundary.x));
            sketchMousePosY = Math.round(map(mousePosY,monitors.boundary.minY, monitors.boundary.maxY, monitors.sketchBoundary.y, monitors.sketchBoundary.height + monitors.sketchBoundary.y));
            
            text(`Sketch Mouse x:${sketchMousePosX}, y:${sketchMousePosY}`, 0, 40);
            ellipse(sketchMousePosX, sketchMousePosY, 10, 10);
            
            monitors.display();
            // monitors.update();
        }

    </script>

    <script ID="Classes">
        class Monitors {
            constructor() {
                //system properties
                this.sceneName = "displayCapture"; 
                this.sourceName = "macOS Screen Capture";   
                this.sourceId = Number(collection.scenes.displayCapture[mainMonitor].sceneItemId);
                this.mainDisplay = "unknown";
                this.displays = this.getDisplays()
                this.boundary = this.getMonitorsBoundary();
                
                // if macOS, swap y axis
                if(isMacOS()){
                    this.swapDisplayY();
                }
                
                //share boundary with obs
                obs.call("SetInputSettings", {
                    inputName: 'Monitor Boundary',
                    inputSettings: {
                        text: `"Width": ${this.boundary.width}, 
                        "Height": ${this.boundary.height}, 
                        "MinX": ${this.boundary.minX}, 
                        "MaxX": ${this.boundary.maxX}, 
                        "MinY": ${this.boundary.minY}, 
                        "MaxY": ${this.boundary.maxY}`,
                    }
                }); 
                
                //sketch properties
                this.zoom = 1;
                this.sketchBoundary = { x: 0, y: 0, width: 400 * this.zoom, height: ((400 * this.zoom) * this.boundary.ratio)};
                this.scaleX = this.sketchBoundary.width / this.boundary.width;
                this.scaleY = this.sketchBoundary.height / this.boundary.height;
                this.obsBoundary = { x: 0, y: 0, width: 1920 * this.zoom, height: ((1920 * this.zoom) * this.boundary.ratio)}
                this.sketchDisplays = this.getSketchDisplays(); 
                this.overlays = this.getOverlays(); 
                
                //sketchViewport
                this.viewport = {x: 0, y: 0, width: 400, height: 225, left: 0 , right: 400, top: 0, bottom: 225};
                this.moving = false

            }
            
            //find the boundary of all monitors in the display capture scene
            getMonitorsBoundary(){
                let minX = this.mainDisplay.monitorPositionX;
                let maxX = this.mainDisplay.monitorPositionX + this.mainDisplay.monitorWidth;
                let minY = this.mainDisplay.monitorPositionY;
                let maxY = this.mainDisplay.monitorPositionY + this.mainDisplay.monitorHeight;
                let width = this.mainDisplay.monitorWidth;
                let height = this.mainDisplay.monitorHeight;
            
                this.displays.forEach((display) => {
                     console.log("Displays ",display);
                    //convert monitors sketch scale
                    if(display.x < minX){
                        minX = display.x;
                    }
                    if(display.x + display.width > maxX){
                        maxX = display.x + display.width;
                    }
                    if(display.y < minY){
                        minY = display.y;
                    }
                    if(display.y + display.height > maxY){
                        maxY = display.y + display.height;
                    }
                });
                height = maxY - minY;
                width = maxX - minX;
            
                return {
                    width: width, 
                    height: height,
                    minX: minX,
                    maxX: maxX,
                    minY: minY,
                    maxY: maxY,
                    ratio: height / width
                };    
            }

            //get the displays in the display capture sources
            getDisplays(){
                let displays = [];
                //TODO: change scene name to variable
                Object.values(collection.scenes['displayCapture']).forEach((value) => {
                    if(typeof value === 'object'){
                        const m = value.inputSettings; 
                        displays.push({
                            
                            name: value.sourceName,
                            displayName: m.displayName,
                            x: m.monitorPositionX,
                            y: m.monitorPositionY,
                            width: m.monitorWidth,
                            height: m.monitorHeight,
                            sceneItemId: Number(value.sceneItemId)
                        });
                        //identify main display
                        if(m.displayName.endsWith("0,0")){
                            console.log("monitor", m.displayName.endsWith("0,0"));
                            this.mainDisplay = m;
                        }
                    }
                });
                return displays;
            }
            
            swapDisplayY(){
                // this.mainDisplay.monitorPositionY = map(this.mainDisplay.monitorPositionY, this.boundary.minY, this.boundary.maxY, this.boundary.minY, this.boundary.height);
                //place main display relative to monitors boundary
                
                this.displays.forEach((display, index) => {
                    console.log(this.mainDisplay.monitorPositionY)
                    console.log("Before swap", display, index);
                    
                    if(display.displayName === this.mainDisplay.displayName){
                        console.log("Main display found", display);
                        // this.displays[index].y = this.boundary.height - display.height;
                        // this.mainDisplay.monitorPositionY = this.boundary.height - display.height;
                        return;
                    }
                    
                    switch(this.mainDisplay.displayName !== display.displayName){
                        case ((display.y + display.height) === this.mainDisplay.monitorPositionY):
                            //display is beside main display
                            console.log("Beside main display")
                            this.displays[index].y = this.mainDisplay.monitorPositionY;
                            break;
                        case (display.y < this.mainDisplay.height && (display.y + this.mainDisplay.monitorHeight) < 0): {
                            //display is below main display
                            console.log("Below main display")
                            this.displays[index].y = this.mainDisplay.monitorHeight - (display.y + display.height);
                            break
                        }
                        case (display.y < this.mainDisplay.monitorHeight && (display.y + this.mainDisplay.monitorHeight) > 0): {
                            //display is overlapping main display
                            console.log("Overlapping main display")
                            this.displays[index].y = this.mainDisplay.monitorHeight - (display.y + display.height);
                            break;
                        }
                        case (display.y >= this.mainDisplay.monitorHeight): {
                            //display is above main display
                            console.log("Above main display")   
                            this.displays[index].y = (-1 * ((display.y - this.mainDisplay.monitorHeight) + display.height)) + display.height;
                            break
                            }
                    }
                });
            }   


            //get the displays in the display capture scene
            getSketchDisplays(){
                const sketchDisplays = [];
                this.displays.forEach((key) => {
                    sketchDisplays.push({
                        name: key.name,
                        x: map(key.x, this.boundary.minX, this.boundary.maxX, 0, this.sketchBoundary.width),
                        y: map(key.y, this.boundary.minY, this.boundary.maxY, 0, this.sketchBoundary.height),
                        width: key.width * this.scaleX,
                        height: key.height * this.scaleY,
                        sceneItemId: key.sceneItemId
                    });
                });
                return sketchDisplays;
            }            


            getOverlays(){
                const overlays = [];
                if(mouseOverlayNames.length > 0){
                    mouseOverlayNames.forEach((key, index) => {
                        console.log("overlay", key);
                        const source = collection.scenes.Mouse_Overlay[key];
                        overlays.push({
                            name: source.sourceName,
                            x: 0,
                            y: 0,
                            sourceWidth: source.inputSettings.width,
                            sourceHeight: source.inputSettings.width * this.boundary.ratio,
                            sceneItemId: Number(source.sceneItemId)
                        });

                        //set initial overlay size to match display capture size
                        obs.call("SetInputSettings", {
                            inputName: overlays[index].name,
                            inputSettings: {
                                width: overlays[index].sourceWidth, 
                                height: overlays[index].sourceHeight,
                            }
                        });

                        obs.call("SetSceneItemTransform", {
                            sceneName: "Mouse_Overlay", //this.sceneName,
                            sceneItemId: overlays[index].sceneItemId,
                            sceneItemTransform: {
                                "positionX": this.obsBoundary.x,
                                "positionY": this.obsBoundary.y,
                                "boundsType": "OBS_BOUNDS_SCALE_INNER",
                                "boundsWidth": map(overlays[index].sourceWidth, 0, overlays[index].sourceWidth, 0, this.obsBoundary.width),
                                "boundsHeight": map(overlays[index].sourceHeight, 0, overlays[index].sourceHeight, 0, this.obsBoundary.height),
                          }
                        })
                    });
                }
                return overlays;
            }

            display() {
                //map xy to sketch scale
                fill(0,0,255,50);
                stroke(0,0,255);
                rect(this.sketchBoundary.x, this.sketchBoundary.y, this.sketchBoundary.width, this.sketchBoundary.height);
                fill(0,255,0,50);
                stroke(0,255,0);
                // rect(this.mainDisplay.monitorPositionX + this.sketchBoundary.x, this.mainDisplay.monitorPositionY + this.sketchBoundary.y, this.mainDisplay.monitorWidth, this.mainDisplay.monitorHeight);
                this.sketchDisplays.forEach((display) => {

                    // console.log("display", display);
                    fill(0, 255, 0, 50);
                    stroke(0, 255, 0);
                    rect(display.x + this.sketchBoundary.x, display.y + this.sketchBoundary.y, display.width, display.height);
                    stroke(0, 0, 0);
                    // fill(255, 0, 0, 100);
                    // text(`x:${Math.round(display.x)}, y:${Math.round(display.y)}`, display.x + 10, display.y + 20);
                    // console.log("display mapped", display);
                }); 
                text(`x:${Math.round(this.sketchDisplays[0].x)}, y:${Math.round(this.sketchDisplays[0].y)}`, 100, 100);
            }
            
            update() {                                          
                const moveSpeed = 5
                if(((sketchMousePosX + moveSpeed > this.viewport.right) || (sketchMousePosX - moveSpeed< this.viewport.left)) 
                || ((sketchMousePosY - moveSpeed < this.viewport.top) || (sketchMousePosY + moveSpeed > this.viewport.bottom))){
                    
                    // console.log("move source")
                    //Set mouseBoundary variables l,r,t,b
                    //check if mouse is near edge X, Y
                    if(sketchMousePosX + moveSpeed <= this.viewport.left && (this.sketchBoundary.x <= 0)){
                        console.log("move left")
                        this.sketchBoundary.x += moveSpeed;
                        this.obsBoundary.x += map(moveSpeed, 0, this.sketchBoundary.width, 0, this.obsBoundary.width);
                        this.updateOBS();
                    }
                    if(sketchMousePosX + moveSpeed >= this.viewport.right && (this.sketchBoundary.x + this.sketchBoundary.width) >= this.viewport.width){
                        console.log("move right")
                        this.sketchBoundary.x -= moveSpeed;
                        this.obsBoundary.x -= map(moveSpeed, 0, this.sketchBoundary.width, 0, this.obsBoundary.width);
                        this.updateOBS();  
       
                    }
                    if(sketchMousePosY - moveSpeed <= this.viewport.top && (this.sketchBoundary.y <= 0)){
                        console.log("move up")
                        this.sketchBoundary.y += moveSpeed;
                        this.obsBoundary.y += map(moveSpeed, 0, this.sketchBoundary.height, 0, this.obsBoundary.height);
                        this.updateOBS();
                    }
                    if(sketchMousePosY + moveSpeed >= this.viewport.bottom && (this.sketchBoundary.y + this.sketchBoundary.height) >= this.viewport.height){
                        console.log("move down")
                        this.sketchBoundary.y -= moveSpeed;
                        this.obsBoundary.y -= map(moveSpeed, 0, this.sketchBoundary.height, 0, this.obsBoundary.height);
                        this.updateOBS();
                    }
                }
            }

            zoomUpdate(){
                this.sketchBoundary.width = 400 * this.zoom;
                this.sketchBoundary.height = ((400 * this.zoom) * this.sketchBoundary.boundaryRatio);
                this.obsBoundary.width = 1920 * this.zoom;
                this.obsBoundary.height = ((1920 * this.zoom) * this.sketchBoundary.boundaryRatio);
                this.scaleX = this.sketchBoundary.width / this.sketchBoundary.boundaryWidth;
                this.scaleY = this.sketchBoundary.height / this.sketchBoundary.boundaryHeight;
                this.displays = this.getDisplays(this.displays);  
                this.display();
                this.updateOBS();

                //update overlays
                if(mouseOverlayNames.length > 0){
                    mouseOverlayNames.forEach((overlay) => {
                        setSourceTransform("displayCapture", overlay.sceneItemId, {
                            "positionX": map(originalMouseX, this.boundary.boundaryMinX, this.monitorsBoundary.boundaryMaxX, this.obsBoundary.x, this.obsBoundary.width + this.obsBoundary.x),
                            "positionY": map(originalMouseY, this.monitorsBoundary.boundaryMinY, this.monitorsBoundary.boundaryMaxY, this.obsBoundary.y, this.obsBoundary.height + this.obsBoundary.y),
                            "boundsType": "OBS_BOUNDS_SCALE_INNER",
                            "boundsWidth": map(20, 0, this.boundary.boundaryWidth, 0, this.obsBoundary.width),
                            "boundsHeight": map(20, 0, this.boundary.boundaryHeight, 0, this.obsBoundary.height),
                        });
                    });
                }
            }

            updateOBS() {
                // console.log("update obs", this.mainY + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, 0, this.obsBoundary.height);
                // console.log("update obs map", map(this.mainY + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, 0, this.obsBoundary.height));
                console.log("boundary", this.boundary);
                console.log("obsBoundary", this.obsBoundary);   
                // obs.call("SetSceneItemTransform", {
                //     sceneName: "displayCapture", //this.sceneName,
                //     sceneItemId: this.sourceId,
                //     sceneItemTransform: {
                //         "positionX": map(this.mainX + this.boundary.x, this.boundary.x, this.boundary.x + this.boundary.width, this.obsBoundary.x, this.obsBoundary.width + this.obsBoundary.x),
                //         "positionY": map(this.mainY + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, + this.obsBoundary.y, this.obsBoundary.height + this.obsBoundary.y) ,
                //         "boundsType": "OBS_BOUNDS_SCALE_INNER",
                //         "boundsWidth": map(this.mainWidth, 0, this.boundary.width, 0, this.obsBoundary.width),
                //         "boundsHeight": map(this.mainHeight, 0, this.boundary.height, 0, this.obsBoundary.height),
                //     }
                // });
                
                // console.log("update obs")   
                this.displays.forEach((display) => {
                    obs.call("SetSceneItemTransform", {
                        sceneName: "displayCapture", //this.sceneName,
                        sceneItemId: display.sceneItemId,
                        sceneItemTransform: {
                            "positionX": map(display.x + this.boundary.x, this.boundary.x, this.boundary.x + this.boundary.width, this.obsBoundary.x, this.obsBoundary.x + this.obsBoundary.width),
                            "positionY": map(display.y + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, this.obsBoundary.y, this.obsBoundary.y + this.obsBoundary.height),
                            "boundsType": "OBS_BOUNDS_SCALE_INNER",
                            "boundsWidth": map(display.width, 0, this.boundary.width, 0, this.obsBoundary.width),
                            "boundsHeight": map(display.height, 0, this.boundary.height, 0, this.obsBoundary.height),
                        }
                    })
                });
            }
        }
    </script>
    
    <script id="OBS Initialization">
        let mouseX,
        mouseY,
        mouseOverlayNames;

        let mainMonitor={};
        let otherMonitors = [];
 
        //set hotkey variables
        obs.on("Identified", async (data) => {
            await obs.call("GetInputSettings", { inputName: "ScreenShare_HotKey_Settings"})
            .then((result) => {
                const hotkeys = JSON.parse(`{${result.inputSettings.text}}`);
                console.log("Hotkeys from Settings Source:", hotkeys);
                followMouseAndZoom_HK = hotkeys.followMouseAndZoom_HK;
                followMouse_HK = hotkeys.followMouse_HK;
                fullScreen_HK = hotkeys.fullScreen_HK;
                toggleMouse_HK = hotkeys.toggleMouse_HK;
                toggleHotkey_HK = hotkeys.toggleHotkey_HK;
                zoomIn_HK = hotkeys.zoomIn_HK;
                zoomOut_HK = hotkeys.zoomOut_HK;
            });
            
            //set display capture source name
            displayCaptureScene = getComputedStyle(document.body).getPropertyValue('--display-capture-scene-name');
            displayCaptureSourceId = getComputedStyle(document.body).getPropertyValue('--display-capture-source-name');
                        
            obs.call("SetInputSettings", {
                inputName: 'keyHotkey',
                inputSettings: {
                    text: fullScreen_HK,
                }
            });

            setTimeout(async () => {
                //OBS adds css after page load, so wait a moment
                //get display info from obs css variables
                mainMonitor = getComputedStyle(document.body).getPropertyValue('--main-display-capture');
                //if tracking multiple monitors, get other monitor names
                if(getComputedStyle(document.body).getPropertyValue('--display-capture-source-name').trim() !== ''){
                    otherMonitors = JSON.parse(getComputedStyle(document.body).getPropertyValue('--display-capture-source-name'));
                }

                //if using mouse overlays, get overlay names
                mouseOverlayNames = JSON.parse(getComputedStyle(document.body).getPropertyValue('--overlay-names'));  
               
                //obsCollection.js functions 
                await getDisplayItems();
                const collectionStatus = await getOBScollection()
                
                // load p5.js library
                const loadP5 = new CustomEvent('loadP5Event')
                window.dispatchEvent(loadP5);
            }, 100);
            
            window.addEventListener('loadP5Event', (e) => {
                loadP5();
            }, false);
            
        });
        
        async function getSceneId(Scene, Source) {
            //create object of OBS collection(scenes and sources)
            return await obs.call("GetSceneItemId", { sceneName: Scene, sourceName: Source})
        }
        
        function loadP5(){
            loadScript("lib/p5.js");
        }
              
        function loadScript(src) {
            // Create a new script element
            var script = document.createElement('script');
            
            // Set the src attribute to the provided script source
            script.src = src;
            
            // Append the script element to the document's head
            // This will initiate the loading and execution of the script
            document.head.appendChild(script);
            
            // Optionally, you can add event listeners to handle load and error states
            script.onload = function() {
                console.log(`Script ${src} loaded successfully.`);
                // console.log("calling createShapes");    
                // createShapes();            
            };

            script.onerror = function() {
                console.error(`Error loading script ${src}.`);
            };
        }

        </script>

    <script id="obsInputRouter">
        //on obs text source settings change
        obs.on("InputSettingsChanged", async function (event) {
            // console.log(event);
            switch (event.inputName) {
                case 'MouseLocation':
                    //-- Get the current mouse position
                    const mousePosition = event.inputSettings.text.split(" ");
                    originalMouseX = Number(mousePosition[0]);      
                    originalMouseY = Number(mousePosition[1]);

                    mousePosX = mousePosition[0];
                    if (isMacOS()) {
                        // Perform macOS-specific mouse position adjustments
                        mousePosY = Math.round(map(mousePosition[1], monitors.boundary.maxY, monitors.boundary.minY, 0, monitors.boundary.height))
                    } else {
                        mousePosY = Math.round(map(mousePosition[1], monitors.boundary.minY, monitors.boundary.maxY, 0, monitors.boundary.height))
                    }
                    
                    //print mouse position to text source
                    obs.call("SetInputSettings", {
                        inputName: 'Mapped Mouse Location',
                        inputSettings: {
                            text: `${mousePosX} ${mousePosY}`,
                        }
                    });
                   break;
                    
                case 'keyHotkey':
                //console.log(event);
                switch (event.inputSettings.text) {
                    case ' ':
                        break;
                    // case followMouseAndZoom_HK: 
                    //     break;
                    case followMouse_HK:
                        break;
                    case fullScreen_HK:
                        // fullScreen();
                        break;
                    case toggleMouse_HK:
                        // toggleSource('scene|||Screen Share','Input Mouse Overlay')
                        break;
                    case toggleHotkey_HK:
                        // toggleSource('scene|||Screen Share','Input Hotkeys')
                        break;
                    case zoomIn_HK:
                        sketchMonitors.zoom += 0.2;
                        sketchMonitors.zoomUpdate();
                        break;
                    case zoomOut_HK:
                        if(sketchMonitors.zoom > 0.4){
                            sketchMonitors.zoom -= 0.2;
                            sketchMonitors.zoomUpdate();
                        }
                        // toggleSource('scene|||Screen Share','Input Hotkeys')
                        break;
                        default:
                            break;
                        }
                    }
                })

        function isMacOS() {
            return navigator.userAgent.indexOf('Mac') !== -1;
        }

        function setSourceTransform(sceneName, sourceId, transform) {
            obs.call("SetSceneItemTransform", {
                sceneName: sceneName,
                sceneItemId: sourceId,
                sceneItemTransform: transform
            });
        }
        </script>

</body>
</html>