<!-- https://uuoocl.github.io/slides-studio/slides_studio_OBS_browser_source.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5 source control</title>
    <style>
         :root {
            --display-width: 0px;
            --left: 0px;
         }
    </style>
</head>
<body>
    <script src="lib/obs-ws.js"></script>
    <script src="js/obsConnect.js"></script>
    <script src="js/obsCollection.js"></script>
    <!-- <script src="lib/p5.js"></script> -->

    <script id="p5 canvas">
        let monitors;
        let monitorsBoundary = { x: 0, y: 0, width: 0, height: 0};
        let originalMouseX = 0, originalMouseY = 0;
        let mousePosX = 0, mousePosY = 0;
        let sketchMousePosX = 0, sketchMousePosY = 0;
        let viewPortMousePosX = 0, viewPortMousePosY = 0;

        function setup() {
            createCanvas(500, 400);
            monitors = new Monitors();   
            // obsDisplays = new ObsDisplays();
            // monitors.updateOBS();
        }
        
        function draw() {
            background(220);
            
            fill(0, 0, 0);
            textSize(20);
            text(`Original x:${originalMouseX}, Original y:${originalMouseY}`, 0, 20);
            text(`Mapped x:${mousePosX}, Mapped y:${mousePosY}`, 0, 40);
            
            translate(50, 50)
            
            //scene Boundary 16:9. 1920x1080 scaled to 400x225 ~21%
            fill(255,0, 0)
            rect(monitors.viewport.x, monitors.viewport.y, monitors.viewport.width, monitors.viewport.height);
            text(`${monitors.viewport.left}`, 0, 100);
            text(`${monitors.viewport.right}`, 400, 100);
            text(`${monitors.viewport.top}`, 200, 0);
            text(`${monitors.viewport.bottom}`, 200, 220);
            

            // monitors.monitorsBoundary
            // ellipse(map(mousePosX, 0, 20, 20));
            sketchMousePosX = Math.round(map(mousePosX,monitors.boundary.minX, monitors.boundary.maxX, 0, monitors.sketchBoundary.width));
            sketchMousePosY = Math.round(map(mousePosY,monitors.boundary.minY, monitors.boundary.maxY, 0, monitors.sketchBoundary.height));
            
            relativeSketchMousePosX = Math.round(map(mousePosX,monitors.boundary.minX, monitors.boundary.maxX, monitors.sketchBoundary.x, monitors.sketchBoundary.width + monitors.sketchBoundary.x));
            relativeSketchMousePosY = Math.round(map(mousePosY,monitors.boundary.minY, monitors.boundary.maxY, monitors.sketchBoundary.y, monitors.sketchBoundary.height + monitors.sketchBoundary.y));
            
            viewPortMousePosX = constrain(sketchMousePosX, monitors.viewport.x, monitors.viewport.x + monitors.viewport.width);
            viewPortMousePosY = constrain(sketchMousePosY, monitors.viewport.y, monitors.viewport.y + monitors.viewport.height);
            

            //mouse position circle
            fill(0, 255, 0);
            ellipse(sketchMousePosX, sketchMousePosY, monitors.mouseRadius, monitors.mouseRadius);
            text(`Sketch Mouse x:${sketchMousePosX}, y:${sketchMousePosY}`, 0, 20);
            
            fill(0, 0, 255);
            text(`Viewport Mouse x:${viewPortMousePosX}, y:${viewPortMousePosX}`, 0, 60);
            ellipse(viewPortMousePosX, viewPortMousePosY, monitors.mouseRadius - 10, monitors.mouseRadius);
            
            fill(0, 255, 0);
            ellipse(relativeSketchMousePosX, relativeSketchMousePosY, monitors.mouseRadius - 20, monitors.mouseRadius - 20);
            text(`relative Sketch Mouse x:${relativeSketchMousePosX}, y:${relativeSketchMousePosY}`, 0, 40);
            
            monitors.display();
            monitors.updatePosition();
        }

    </script>

    <script ID="Classes">
        class Monitors {
            constructor() {
                //system properties
                this.sceneName = "displayCapture"; 
                this.sourceName = "macOS Screen Capture";   
                this.boundary = this.getMonitorsBoundary();
                this.displays = this.getDisplays()
                console.log("monitors boundary", this.boundary);
                //share boundary with obs
                obs.call("SetInputSettings", {
                    inputName: 'Monitor Boundary',
                    inputSettings: {
                        text: `"Width": ${this.boundary.width}, 
                        "Height": ${this.boundary.height}, 
                        "MinX": ${this.boundary.minX}, 
                        "MaxX": ${this.boundary.maxX}, 
                        "MinY": ${this.boundary.minY}, 
                        "MaxY": ${this.boundary.maxY}`,
                    }
                }); 
                
                //sketch properties
                this.zoom = 1;
                this.sketchBoundary = { x: 0, y: 0, width: 400 * this.zoom, height: ((400 * this.zoom) * this.boundary.ratio)};
                this.scaleX = this.sketchBoundary.width / this.boundary.width;
                this.scaleY = this.sketchBoundary.height / this.boundary.height;
                this.obsBoundary = { x: 0, y: 0, width: 1920 * this.zoom, height: ((1920 * this.zoom) * this.boundary.ratio)}
                this.sketchDisplays = this.getSketchDisplays(); 
                console.log(JSON.stringify(this.sketchDisplays))
                this.overlays = this.getOverlays(); 
                
                //sketchViewport
                this.viewport = {x: 0, y: 0, width: 400, height: 225, left: 0 , right: 400, top: 0, bottom: 225};
                this.mouseRadius = 50; 
            }
            
            //find the boundary of all monitors in the display capture scene
            getMonitorsBoundary(){
                let minX = 0;
                let maxX = 0;
                let minY = 0;
                let maxY = 0;
                let width = 0;
                let height = 0;
            
                Object.values(collection.scenes['displayCapture']).forEach((value) => {
                     if(typeof value === 'object'){
                        const display = value.inputSettings;
                        //convert monitors sketch scale
                        if(display.monitorPositionX < minX){
                            minX = display.monitorPositionX;
                        }
                        if(display.monitorPositionX + display.monitorWidth > maxX){
                            maxX = display.monitorPositionX + display.monitorWidth;
                        }
                        if(display.monitorPositionY < 0){
                            minY = display.monitorPositionY;
                        }
                        if(display.monitorPositionY + display.monitorHeight > maxY){
                            maxY = display.monitorPositionY + display.monitorHeight;
                        }
                    }
                });
                height = (maxY - minY);
                width = maxX - minX;
                
            
                return {
                    width: width, 
                    height: height,
                    minX: minX,
                    maxX: maxX,
                    minY: minY,
                    maxY: maxY,
                    ratio: height / width
                };    
            }

            //get the displays in the display capture sources
            getDisplays(){
                let displays = [];
                //TODO: change scene name to variable
                Object.values(collection.scenes['displayCapture']).forEach((value) => {
                    if(typeof value === 'object'){
                        const m = value.inputSettings; 
                        displays.push({           
                            name: value.sourceName,
                            displayName: m.displayName,
                            x: m.monitorPositionX,
                            y: m.monitorPositionY,
                            width: m.monitorWidth,
                            height: m.monitorHeight,
                            sceneItemId: Number(value.sceneItemId)
                        });

                        if(isMacOS){
                            //swap y axis for macOS
                            //get rectangle upper left corner y position
                            const index = displays.length - 1;
                            displays[index].y = m.monitorPositionY + m.monitorHeight;
                            //map y position from cartesian to screen coordinates
                            displays[index].y = map(displays[index].y, this.boundary.maxY, this.boundary.minY, this.boundary.minY, this.boundary.maxY);
                        }
                    }
                });
                console.log("displays", JSON.stringify(displays));
                console.log("displays", displays);
                return displays;
            }
            
            //map displays to sketch scale
            getSketchDisplays(){
                const sketchDisplays = [];
                this.displays.forEach((key) => {
                    sketchDisplays.push({
                        name: key.name,
                        x: map(key.x, this.boundary.minX, this.boundary.maxX, 0, this.sketchBoundary.width),
                        y: map(key.y, this.boundary.minY, this.boundary.maxY, 0, this.sketchBoundary.height),
                        width: key.width * this.scaleX,
                        height: key.height * this.scaleY,
                        sceneItemId: key.sceneItemId
                    });
                });
                return sketchDisplays;
            }            

            getOverlays(){
                const overlays = [];
                Object.values(collection.scenes['Mouse_Overlay']).forEach((value) => {
                    if(typeof value === 'object'){
                        const o = value.inputSettings; 
                        overlays.push({           
                            name: value.sourceName,
                            x: 0,
                            y: 0,
                            width: o.width,
                            height: o.height,
                            sceneItemId: Number(value.sceneItemId)
                        });
                    }
                });
                return overlays;        
            }

            display() {
                //map xy to sketch scale
                fill(0,0,255,50);
                stroke(0,0,255);
                rect(this.sketchBoundary.x, this.sketchBoundary.y, this.sketchBoundary.width, this.sketchBoundary.height);
                fill(0,255,0,50);
                stroke(0,255,0);
                this.sketchDisplays.forEach((display) => {
                    // const x = map(display.x, this.boundary.minX, this.boundary.maxX, 0, this.sketchBoundary.width);
                    // const y = map(display.y, this.boundary.minY, this.boundary.maxY, 0, this.sketchBoundary.height);
                    // console.log("display x", x);
                    // console.log("display", display);
                    fill(0, 255, 0, 50);
                    stroke(0, 255, 0);
                    rect(display.x * this.zoom, display.y * this.zoom , display.width * this.zoom, display.height * this.zoom);
                    stroke(0, 0, 0);
                    // fill(255, 0, 0, 100);
                    // text(`x:${Math.round(display.x)}, y:${Math.round(display.y)}`, display.x + 10, display.y + 20);
                    // console.log("display mapped", display);
                }); 
                text(`x:${Math.round(this.sketchDisplays[0].x)}, y:${Math.round(this.sketchDisplays[0].y)}`, 100, 100);
            }
            
            updatePosition() {                                          
                const moveSpeed = 10
                //check if move update is needed
                if(((relativeSketchMousePosX + this.mouseRadius > this.viewport.right) || (relativeSketchMousePosX - this.mouseRadius < this.viewport.left)) 
                || ((relativeSketchMousePosX - this.mouseRadius < this.viewport.top) || (relativeSketchMousePosX + this.mouseRadius > this.viewport.bottom))
                ){ 
                    if(relativeSketchMousePosX - this.mouseRadius <= this.viewport.left && (this.sketchBoundary.x) <= 0){
                        // console.log("move left")
                        if(relativeSketchMousePosX < this.viewport.left){
                            this.sketchBoundary.x = -1 * (this.sketchBoundary.x - relativeSketchMousePosX);
                        } else {
                            this.sketchBoundary.x += moveSpeed;
                        }
                        
                        this.sketchBoundary.x = constrain(this.sketchBoundary.x, this.viewport.width - this.sketchBoundary.width, 0)

                        this.updateSketchDisplays()
                        
                        this.obsBoundary.x = map(this.sketchBoundary.x, this.sketchBoundary.x, this.sketchBoundary.width, 0, this.obsBoundary.width);
                        this.updateOBS();  
                        // return
                    }

                    if(relativeSketchMousePosX + this.mouseRadius >= this.viewport.right && (this.sketchBoundary.x) <= 0){
                        // console.log("move right")

                        if(relativeSketchMousePosX > this.viewport.right){
                             this.sketchBoundary.x = -1 * (this.sketchBoundary.x + relativeSketchMousePosX );
                        } else{
                            this.sketchBoundary.x -= moveSpeed;
                        }

                        this.sketchBoundary.x = constrain(this.sketchBoundary.x, this.viewport.width - this.sketchBoundary.width, 0)

                        this.updateSketchDisplays()
                        
                        this.obsBoundary.x = map(this.sketchBoundary.x, this.sketchBoundary.x, this.sketchBoundary.width, 0, this.obsBoundary.width);
                        this.updateOBS();  
                        // return
                    }

                    if(relativeSketchMousePosY - this.mouseRadius <= this.viewport.top && (this.sketchBoundary.y) <= 0){
                        // console.log("move up")

                        if(relativeSketchMousePosX <= this.viewport.top){
                            this.sketchBoundary.y =  -1 * (this.sketchBoundary.y - relativeSketchMousePosY);
                        } else {
                            this.sketchBoundary.y += moveSpeed;
                        }
                        
                        this.sketchBoundary.y = constrain(this.sketchBoundary.y, this.viewport.height - this.sketchBoundary.height, 0)

                        this.updateSketchDisplays()
                        
                        this.obsBoundary.y = map(this.sketchBoundary.y, this.sketchBoundary.y, this.sketchBoundary.height, 0, this.obsBoundary.height);
                        this.updateOBS();  
                        // return
                    }

                    if(relativeSketchMousePosY + this.mouseRadius >= this.viewport.bottom && (this.sketchBoundary.y) <= 0){
                        // console.log("move down")

                        if(relativeSketchMousePosY >= this.viewport.bottom){
                            this.sketchBoundary.y = -1 * (this.sketchBoundary.y + relativeSketchMousePosY)
                        } else {
                            this.sketchBoundary.y -= moveSpeed;
                        }

                        this.sketchBoundary.y = constrain(this.sketchBoundary.y, this.viewport.height - this.sketchBoundary.height, 0)

                        this.updateSketchDisplays()
                        
                        this.obsBoundary.y = map(this.sketchBoundary.y, this.sketchBoundary.y, this.sketchBoundary.height, 0, this.obsBoundary.height);
                        this.updateOBS();  
                        // return
                    }

            }
        }

            updateSketchDisplays(){
                this.sketchDisplays.forEach((display, index) => {
                    // console.log(this.displays[index].y, this.boundary.minY, this.boundary.maxY, this.sketchBoundary.y, this.sketchBoundary.y + this.sketchBoundary.height)
                    display.x = map(this.displays[index].x, this.boundary.minX, this.boundary.maxX, this.sketchBoundary.x, this.sketchBoundary.x + this.sketchBoundary.width);
                    display.y = map(this.displays[index].y, this.boundary.minY, this.boundary.maxY, this.sketchBoundary.y, this.sketchBoundary.y + this.sketchBoundary.height);
                    display.width = this.displays[index].width * this.scaleX;
                    display.height = this.displays[index].height * this.scaleY;
                })
            }
            
            updateZoom(){
                this.sketchBoundary.width = 400 * this.zoom;
                this.sketchBoundary.height = ((400 * this.zoom) * this.boundary.ratio);
                this.obsBoundary.width = 1920 * this.zoom;
                this.obsBoundary.height = ((1920 * this.zoom) * this.boundary.ratio);
                this.scaleX = this.sketchBoundary.width / this.boundary.width;
                this.scaleY = this.sketchBoundary.height / this.boundary.height;
                //this.displays = this.getDisplays(this.sketchDisplays);  
                this.display();
                this.updateOBS();

                this.sketchDisplays.forEach((display, index) => {
                    display.x = map(this.displays[index].x, this.boundary.minX, this.boundary.maxX, this.sketchBoundary.x, this.sketchBoundary.width);
                    display.y = map(this.displays[index].y, this.boundary.minY, this.boundary.maxY, this.sketchBoundary.y, this.sketchBoundary.height);
                    display.width = this.displays[index].width * this.scaleX;
                    display.height = this.displays[index].height * this.scaleY;
                }); 
                
                // //update overlays
                // if(this.overlays.length > 0){
                //     setSourceTransform("displayCapture", overlay.sceneItemId, {
                //         "positionX": map(originalMouseX, this.boundary.minX, this.boundary.maxX, this.obsBoundary.x, this.obsBoundary.width + this.obsBoundary.x),
                //         "positionY": map(originalMouseY, this.boundary.minY, this.boundary.maxY, this.obsBoundary.y, this.obsBoundary.height + this.obsBoundary.y),
                //         "boundsType": "OBS_BOUNDS_SCALE_INNER",
                //         "boundsWidth": map(20, 0, this.sketchBoundary.width, 0, this.obsBoundary.width),
                //         "boundsHeight": map(20, 0, this.sketchBoundary.height, 0, this.obsBoundary.height),
                //     });
                // };
            }
            

            updateOBS() {
                // console.log("update obs", this.mainY + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, 0, this.obsBoundary.height);
                // console.log("update obs map", map(this.mainY + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, 0, this.obsBoundary.height));
                // console.log("boundary", this.boundary);
                // console.log("obsBoundary", this.obsBoundary);   
                
                // console.log("update obs")   
                this.sketchDisplays.forEach((display) => {
                    // console.log("update obs display", JSON.stringify(display));
                    obs.call("SetSceneItemTransform", {
                        sceneName: "displayCapture",
                        sceneItemId: Number(display.sceneItemId),
                        sceneItemTransform: {
                            "positionX": map(display.x + this.sketchBoundary.x, this.sketchBoundary.x, this.sketchBoundary.x + this.sketchBoundary.width, this.obsBoundary.x, this.obsBoundary.x + this.obsBoundary.width),
                            "positionY": map(display.y + this.sketchBoundary.y, this.sketchBoundary.y, this.sketchBoundary.y + this.sketchBoundary.height, this.obsBoundary.y, this.obsBoundary.y + this.obsBoundary.height),
                            "boundsType": "OBS_BOUNDS_SCALE_INNER",
                            "boundsWidth": map(display.width, 0, this.sketchBoundary.width, 0, this.obsBoundary.width),
                            "boundsHeight": map(display.height, 0, this.sketchBoundary.height, 0, this.obsBoundary.height),
                        }
                    })
                });
                    
                //update overlays
                this.overlays.forEach((overlay, index) => {
                    obs.call("SetSceneItemTransform", {
                        sceneName: "Mouse_Overlay", //this.sceneName,
                        sceneItemId: overlay.sceneItemId,
                        sceneItemTransform: {
                            "positionX": map(this.sketchBoundary.x, this.sketchBoundary.x, this.sketchBoundary.x + this.sketchBoundary.width, this.obsBoundary.x, this.obsBoundary.x + this.obsBoundary.width),
                            "positionY": map(this.sketchBoundary.y, this.sketchBoundary.y, this.sketchBoundary.y + this.sketchBoundary.height, this.obsBoundary.y, this.obsBoundary.y + this.obsBoundary.height),
                            "boundsType": "OBS_BOUNDS_SCALE_INNER",
                            "boundsWidth": map(overlay.width, 0, overlay.width, 0, this.obsBoundary.width),
                            "boundsHeight": map(overlay.height, 0, overlay.height, 0, this.obsBoundary.height),
                        } 
                    })
                });

                //print sketch boundary
                        obs.call("SetInputSettings", {
            inputName: 'zoomDisplay',
            inputSettings: {
                text: `${sketchMousePosX} ${sketchMousePosY}
${this.viewport.top} ${this.viewport.left} ${this.viewport.right} ${this.viewport.bottom}
${this.sketchBoundary.x} ${this.sketchBoundary.y} ${this.sketchBoundary.width} ${this.sketchBoundary.height}
${this.zoom}}
`,
            }
        });
            }
        }
    </script>
    
    <script id="OBS Initialization">
        let mouseX,
        mouseY,
        displayCaptureSceneName,
        mouseOverlaySceneName;
 
        //set hotkey variables
        obs.on("Identified", async (data) => {
            await obs.call("GetInputSettings", { inputName: "ScreenShare_HotKey_Settings"})
            .then((result) => {
                const hotkeys = JSON.parse(`{${result.inputSettings.text}}`);
                console.log("Hotkeys from Settings Source:", hotkeys);
                followMouseAndZoom_HK = hotkeys.followMouseAndZoom_HK;
                followMouse_HK = hotkeys.followMouse_HK;
                fullScreen_HK = hotkeys.fullScreen_HK;
                toggleMouse_HK = hotkeys.toggleMouse_HK;
                toggleHotkey_HK = hotkeys.toggleHotkey_HK;
                zoomIn_HK = hotkeys.zoomIn_HK;
                zoomOut_HK = hotkeys.zoomOut_HK;
            });
            
            
            obs.call("SetInputSettings", {
                inputName: 'keyHotkey',
                inputSettings: {
                    text: fullScreen_HK,
                }
            });
            
            setTimeout(async () => {
                //OBS adds css after page load, so wait a moment
                //get display info from obs css variables
                displayCaptureSceneName = getComputedStyle(document.body).getPropertyValue('--display-capture-scene-name');
                mouseOverlaySceneName = getComputedStyle(document.body).getPropertyValue('--mouse-overlay-scene-name');

                //obsCollection.js functions 
                await getDisplayItems();
                const collectionStatus = await getOBScollection()
                
                // load p5.js library
                const loadP5 = new CustomEvent('loadP5Event')
                window.dispatchEvent(loadP5);
            }, 100);
            
            window.addEventListener('loadP5Event', (e) => {
                loadP5();
            }, false);
            
        });
        
        async function getSceneId(Scene, Source) {
            //create object of OBS collection(scenes and sources)
            return await obs.call("GetSceneItemId", { sceneName: Scene, sourceName: Source})
        }
        
        function loadP5(){
            loadScript("lib/p5.js");
        }
              
        function loadScript(src) {
            // Create a new script element
            var script = document.createElement('script');
            
            // Set the src attribute to the provided script source
            script.src = src;
            
            // Append the script element to the document's head
            // This will initiate the loading and execution of the script
            document.head.appendChild(script);
            
            // Optionally, you can add event listeners to handle load and error states
            script.onload = function() {
                console.log(`Script ${src} loaded successfully.`);
                // console.log("calling createShapes");    
                // createShapes();            
            };

            script.onerror = function() {
                console.error(`Error loading script ${src}.`);
            };
        }
        </script>

    <script id="obsInputRouter">
        //on obs text source settings change
        obs.on("InputSettingsChanged", async function (event) {
            // console.log(event);
            switch (event.inputName) {
                case 'MouseLocation':
                    //-- Get the current mouse position
                    const mousePosition = event.inputSettings.text.split(" ");
                    originalMouseX = Number(mousePosition[0]);      
                    originalMouseY = Number(mousePosition[1]);

                    mousePosX = mousePosition[0];
                    if (isMacOS()) {
                        // Perform macOS-specific mouse position adjustments
                        mousePosY = Math.round(map(mousePosition[1], monitors.boundary.maxY, monitors.boundary.minY, 0, monitors.boundary.height))
                    } else {
                        mousePosY = Math.round(map(mousePosition[1], monitors.boundary.minY, monitors.boundary.maxY, 0, monitors.boundary.height))
                    }
                    
                    //print mouse position to text source
                    obs.call("SetInputSettings", {
                        inputName: 'Mapped Mouse Location',
                        inputSettings: {
                            text: `${mousePosX} ${mousePosY}`,
                        }
                    });
                   break;
                    
                case 'keyHotkey':
                //console.log(event);
                switch (event.inputSettings.text) {
                    case ' ':
                        break;
                    // case followMouseAndZoom_HK: 
                    //     break;
                    case followMouse_HK:
                        break;
                    case fullScreen_HK:
                        // fullScreen();
                        break;
                    case toggleMouse_HK:
                        // toggleSource('scene|||Screen Share','Input Mouse Overlay')
                        break;
                    case toggleHotkey_HK:
                        // toggleSource('scene|||Screen Share','Input Hotkeys')
                        break;
                    case zoomIn_HK:
                        monitors.zoom = constrain(monitors.zoom + 1, 1, 5);
                        monitors.updateZoom();
                        break;
                        case zoomOut_HK:
                        monitors.zoom = constrain(monitors.zoom - 1, 1, 5);
                        monitors.updateZoom();
                        // toggleSource('scene|||Screen Share','Input Hotkeys')
                        break;
                        default:
                            break;
                        }
                    }
                })

        function isMacOS() {
            return navigator.userAgent.indexOf('Mac') !== -1;
        }

        function setSourceTransform(sceneName, sourceId, transform) {
            obs.call("SetSceneItemTransform", {
                sceneName: sceneName,
                sceneItemId: sourceId,
                sceneItemTransform: transform
            });
        }
        </script>

</body>
</html>