<!-- https://uuoocl.github.io/slides-studio/slides_studio_OBS_browser_source.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>P5 source control</title>
    <style>
         :root {
            --display-width: 0px;
            --left: 0px;
         }
    </style>
</head>
<body>
    <script src="lib/obs-ws.js"></script>
    <script src="js/obsConnect.js"></script>
    <script src="js/obsCollection.js"></script>
    <!-- <script src="lib/p5.js"></script> -->

    <script id="p5 canvas">
        let monitors;
        let sketchMonitors;
        let sourceBackgroundRectangle;
        let originalMouseX = 0, originalMouseY = 0;
        let mousePosX = 0, mousePosY = 0;
        let sketchMousePosX = 0, sketchMousePosY = 0;

        function setup() {
            createCanvas(500, 400);
            monitors = new Monitors();  
            sketchMonitors = new SketchMonitors();
            // obsDisplays = new ObsDisplays();
            sketchMonitors.updateOBS();
        }
        
        function draw() {
            background(220);
            
            fill(0, 0, 0);
            textSize(20);
            text(`Original x:${originalMouseX}, Original y:${originalMouseY}`, 0, 20);
            text(`Mapped x:${mousePosX}, Mapped y:${mousePosY}`, 0, 40);
            
            translate(50, 50)
            
            //scene Boundary 16:9. 1920x1080 scaled to 400x225 ~21%
            fill(255,0, 0)
            rect(sketchMonitors.viewport.x, sketchMonitors.viewport.y, sketchMonitors.viewport.width, sketchMonitors.viewport.height);
            text(`${sketchMonitors.viewport.left}`, 0, 100);
            text(`${sketchMonitors.viewport.right}`, 400, 100);
            text(`${sketchMonitors.viewport.top}`, 200, 0);
            text(`${sketchMonitors.viewport.bottom}`, 200, 220);
            
            //mouse position circle
            fill(0, 0, 255);
            // monitors.monitorsBoundary
            // ellipse(map(mousePosX, 0, 20, 20));
            sketchMousePosX = Math.round(map(mousePosX,monitors.monitorsBoundary.boundaryMinX, monitors.monitorsBoundary.boundaryMaxX, sketchMonitors.boundary.x, sketchMonitors.boundary.width + sketchMonitors.boundary.x));
            sketchMousePosY = Math.round(map(mousePosY,monitors.monitorsBoundary.boundaryMinY, monitors.monitorsBoundary.boundaryMaxY, sketchMonitors.boundary.y, sketchMonitors.boundary.height + sketchMonitors.boundary.y));
            
            text(`Sketch Mouse x:${sketchMousePosX}, y:${sketchMousePosY}`, 0, 40);
            ellipse(sketchMousePosX, sketchMousePosY, 10, 10);
            
            sketchMonitors.display();
            sketchMonitors.update();
        }

    </script>

    <script ID="Classes">
        class Monitors {
            constructor() {
                this.mainX = collection.scenes.displayCapture[mainMonitor].inputSettings.monitorPositionX;
                this.mainY = collection.scenes.displayCapture[mainMonitor].inputSettings.monitorPositionY;
                this.mainWidth = collection.scenes.displayCapture[mainMonitor].inputSettings.monitorWidth;
                this.mainHeight = collection.scenes.displayCapture[mainMonitor].inputSettings.monitorHeight;
                this.sceneName = "displayCapture"; 
                this.sourceName = "macOS Screen Capture";   
                this.sourceId = Number(collection.scenes.displayCapture[mainMonitor].sceneItemId);
                this.moving = false
                this.displays = this.getDisplays()
                
                //if macOS, swap y axis
                if(isMacOS()){
                    this.swapDisplayY();
                }

                this.monitorsBoundary = this.getAllDisplaysSize();
                obs.call("SetInputSettings", {
                    inputName: 'Monitor Boundary',
                    inputSettings: {
                        text: `"Width": ${this.monitorsBoundary.boundaryWidth}, 
"Height": ${this.monitorsBoundary.boundaryHeight}, 
"MinX": ${this.monitorsBoundary.boundaryMinX}, 
"MaxX": ${this.monitorsBoundary.boundaryMaxX}, 
"MinY": ${this.monitorsBoundary.boundaryMinY}, 
"MaxY": ${this.monitorsBoundary.boundaryMaxY}`,
                    }
                }); 

                this.sketchScale();
            }

            //scale monitors to fit in p5 canvas
            sketchScale(){
                const scaleX = 400 / this.monitorsBoundary.boundaryWidth;
                const scaleY = 225 / this.monitorsBoundary.boundaryHeight;                
            }

            //get the displays in the display capture scene
            getDisplays(){
                let displays = [];
                otherMonitors.forEach((key) => {
                    displays.push({
                        name: collection.scenes.displayCapture[key].sourceName,
                        x: collection.scenes.displayCapture[key].inputSettings.monitorPositionX,
                        y: collection.scenes.displayCapture[key].inputSettings.monitorPositionY,
                        width: collection.scenes.displayCapture[key].inputSettings.monitorWidth,
                        height: collection.scenes.displayCapture[key].inputSettings.monitorHeight,
                        sceneItemId: Number(collection.scenes.displayCapture[key].sceneItemId)
                    });
                });
                return displays;
            }

            swapDisplayY(){
                this.displays.forEach((display) => {
                    switch(true){
                        case ((display.y + display.height) === this.mainHeight):
                            //display is beside main display
                            console.log("Beside main display")
                            display.y = this.mainY;
                            break;
                        case (display.y < this.mainHeight && (display.y + this.mainHeight) < 0): {
                            //display is below main display
                            console.log("Below main display")
                            display.y = this.mainHeight - (display.y + display.height);
                            break
                        }
                        case (display.y < this.mainHeight && (display.y + this.mainHeight) > 0): {
                            //display is overlapping main display
                            console.log("Overlapping main display")
                            display.y = this.mainHeight - (display.y + display.height);
                            break;
                        }
                        case (display.y >= this.mainHeight): {
                            //display is above main display
                            console.log("Above main display")   
                            display.y = -1 * ((display.y - this.mainHeight) + display.height);
                            break
                        }
                    }
                });
            }   
            
            getAllDisplaysSize(){
                let boundaryMinX = this.mainX;
                let boundaryMaxX = this.mainX + this.mainWidth;
                let boundaryMinY = this.mainY;
                let boundaryMaxY = this.mainY + this.mainHeight;  
                let boundaryWidth = this.mainWidth;
                let boundaryHeight = this.mainHeight;
                this.displays.forEach((display) => {
                    // console.log("Displays ",display);
                    //convert monitors sketch scale
                    if(display.x < boundaryMinX){
                        boundaryMinX = display.x;
                    }
                    if(display.x + display.width > boundaryMaxX){
                        boundaryMaxX = display.x + display.width;
                    }
                    if(display.y < boundaryMinY){
                        boundaryMinY = display.y;
                    }
                    if(display.y + display.height > boundaryMaxY){
                        boundaryMaxY = display.y + display.height;
                    }
                });
                boundaryHeight = boundaryMaxY - boundaryMinY;
                boundaryWidth = boundaryMaxX - boundaryMinX;

                return {
                    boundaryWidth: boundaryWidth, 
                    boundaryHeight: boundaryHeight,
                    boundaryMinX: boundaryMinX,
                    boundaryMaxX: boundaryMaxX,
                    boundaryMinY: boundaryMinY,
                    boundaryMaxY: boundaryMaxY,
                    boundaryRatio: boundaryHeight / boundaryWidth
                };    
            }
        }

        class SketchMonitors {
            constructor() {
                this.zoom = 1;
                this.boundary = { x: 0, y: 0, width: 400 * this.zoom, height: ((400 * this.zoom) * monitors.monitorsBoundary.boundaryRatio)};
                this.obsBoundary = { x: 0, y: 0, width: 1920 * this.zoom, height: ((1920 * this.zoom) * monitors.monitorsBoundary.boundaryRatio)}
                this.scaleX = this.boundary.width / monitors.monitorsBoundary.boundaryWidth;
                this.scaleY = this.boundary.height / monitors.monitorsBoundary.boundaryHeight;
                this.mainX = map(monitors.mainX, monitors.monitorsBoundary.boundaryMinX, monitors.monitorsBoundary.boundaryMaxX, 0, this.boundary.width);
                this.mainY = map(monitors.mainY, monitors.monitorsBoundary.boundaryMinY, monitors.monitorsBoundary.boundaryMaxY, 0, this.boundary.height);
                this.mainWidth = monitors.mainWidth * this.scaleX;
                this.mainHeight = monitors.mainHeight * this.scaleY;
                this.sceneName = monitors.sceneName; 
                this.sourceId = monitors.sourceId;   
                this.displays = this.getDisplays(monitors.displays); 
                this.overlays = this.getOverlays(); 
                
                //sketchViewport
                this.viewport = {x: 0, y: 0, width: 400, height: 225, left: 0 , right: 400, top: 0, bottom: 225};
            }   

            //get the displays in the display capture scene
            getDisplays(monitorDisplays){
                const displays = [];
                monitorDisplays.forEach((key) => {
                    displays.push({
                        name: key.name,
                        x: map(key.x, monitors.monitorsBoundary.boundaryMinX, monitors.monitorsBoundary.boundaryMaxX, 0, this.boundary.width),
                        y: map(key.y, monitors.monitorsBoundary.boundaryMinY, monitors.monitorsBoundary.boundaryMaxY, 0, this.boundary.height),
                        width: key.width * this.scaleX,
                        height: key.height * this.scaleY,
                        sceneItemId: key.sceneItemId

                    });
                });
                return displays;
            }

            getOverlays(){
                const overlays = [];
                if(mouseOverlayNames.length > 0){
                    mouseOverlayNames.forEach((key, index) => {
                        console.log("overlay", key);
                        const source = collection.scenes.Mouse_Overlay[key];
                        overlays.push({
                            name: source.sourceName,
                            x: 0,
                            y: 0,
                            sourceWidth: source.inputSettings.width,
                            sourceHeight: source.inputSettings.width * monitors.monitorsBoundary.boundaryRatio,
                            sceneItemId: Number(source.sceneItemId)
                        });

                        //set initial overlay size to match display capture size
                        obs.call("SetInputSettings", {
                            inputName: overlays[index].name,
                            inputSettings: {
                                width: overlays[index].sourceWidth, 
                                height: overlays[index].sourceHeight,
                            }
                        });

                        obs.call("SetSceneItemTransform", {
                            sceneName: "Mouse_Overlay", //this.sceneName,
                            sceneItemId: overlays[index].sceneItemId,
                            sceneItemTransform: {
                                "positionX": this.obsBoundary.x,
                                "positionY": this.obsBoundary.y,
                                "boundsType": "OBS_BOUNDS_SCALE_INNER",
                                "boundsWidth": map(overlays[index].sourceWidth, 0, overlays[index].sourceWidth, 0, this.obsBoundary.width),
                                "boundsHeight": map(overlays[index].sourceHeight, 0, overlays[index].sourceHeight, 0, this.obsBoundary.height),
                          }
                        })
                    });
                }
                return overlays;
            }

            

            display() {
                //map xy to sketch scale
                fill(0,0,255,50);
                stroke(0,0,255);
                rect(this.boundary.x, this.boundary.y, this.boundary.width, this.boundary.height);
                fill(0,255,0,50);
                stroke(0,255,0);
                rect(this.mainX + this.boundary.x, this.mainY + this.boundary.y, this.mainWidth, this.mainHeight);
                text(`x:${Math.round(this.mainX)}, y:${Math.round(this.mainY)}`, 100, 100);
                this.displays.forEach((display) => {
                    // console.log("display", display);
                    fill(0, 255, 0, 50);
                    stroke(0, 255, 0);
                    rect(display.x + this.boundary.x, display.y + this.boundary.y, display.width, display.height);
                    stroke(0, 0, 0);
                    // fill(255, 0, 0, 100);
                    // text(`x:${Math.round(display.x)}, y:${Math.round(display.y)}`, display.x + 10, display.y + 20);
                    // console.log("display mapped", display);
                }); 
            }
            
            update() {                                          
                const moveSpeed = 5
                if(((sketchMousePosX + moveSpeed > this.viewport.right) || (sketchMousePosX - moveSpeed< this.viewport.left)) 
                || ((sketchMousePosY - moveSpeed < this.viewport.top) || (sketchMousePosY + moveSpeed > this.viewport.bottom))){
                    
                    // console.log("move source")
                    //Set mouseBoundary variables l,r,t,b
                    //check if mouse is near edge X, Y
                    if(sketchMousePosX + moveSpeed <= this.viewport.left && (this.boundary.x <= 0)){
                        console.log("move left")
                        this.boundary.x += moveSpeed;
                        this.obsBoundary.x += map(moveSpeed, 0, this.boundary.width, 0, this.obsBoundary.width);
                        this.updateOBS();
                    }
                    if(sketchMousePosX + moveSpeed >= this.viewport.right && (this.boundary.x + this.boundary.width) >= this.viewport.width){
                        console.log("move right")
                        this.boundary.x -= moveSpeed;
                        this.obsBoundary.x -= map(moveSpeed, 0, this.boundary.width, 0, this.obsBoundary.width);
                        this.updateOBS();  
       
                    }
                    if(sketchMousePosY - moveSpeed <= this.viewport.top && (this.boundary.y <= 0)){
                        console.log("move up")
                        this.boundary.y += moveSpeed;
                        this.obsBoundary.y += map(moveSpeed, 0, this.boundary.height, 0, this.obsBoundary.height);
                        this.updateOBS();
                    }
                    if(sketchMousePosY + moveSpeed >= this.viewport.bottom && (this.boundary.y + this.boundary.height) >= this.viewport.height){
                        console.log("move down")
                        this.boundary.y -= moveSpeed;
                        this.obsBoundary.y -= map(moveSpeed, 0, this.boundary.height, 0, this.obsBoundary.height);
                        this.updateOBS();
                    }
                }
            }

            zoomUpdate(){
                this.boundary.width = 400 * this.zoom;
                this.boundary.height = ((400 * this.zoom) * monitors.monitorsBoundary.boundaryRatio);
                this.obsBoundary.width = 1920 * this.zoom;
                this.obsBoundary.height = ((1920 * this.zoom) * monitors.monitorsBoundary.boundaryRatio);
                this.scaleX = this.boundary.width / monitors.monitorsBoundary.boundaryWidth;
                this.scaleY = this.boundary.height / monitors.monitorsBoundary.boundaryHeight;
                this.mainX = map(monitors.mainX, monitors.monitorsBoundary.boundaryMinX, monitors.monitorsBoundary.boundaryMaxX, 0, this.boundary.width);
                this.mainY = map(monitors.mainY, monitors.monitorsBoundary.boundaryMinY, monitors.monitorsBoundary.boundaryMaxY, 0, this.boundary.height);
                this.mainWidth = monitors.mainWidth * this.scaleX;
                this.mainHeight = monitors.mainHeight * this.scaleY;
                this.displays = this.getDisplays(monitors.displays);  
                this.display();
                this.updateOBS();

                //update overlays
                if(mouseOverlayNames.length > 0){
                    mouseOverlayNames.forEach((overlay) => {
                        setSourceTransform("displayCapture", overlay.sceneItemId, {
                            "positionX": map(originalMouseX, monitors.monitorsBoundary.boundaryMinX, monitors.monitorsBoundary.boundaryMaxX, this.obsBoundary.x, this.obsBoundary.width + this.obsBoundary.x),
                            "positionY": map(originalMouseY, monitors.monitorsBoundary.boundaryMinY, monitors.monitorsBoundary.boundaryMaxY, this.obsBoundary.y, this.obsBoundary.height + this.obsBoundary.y),
                            "boundsType": "OBS_BOUNDS_SCALE_INNER",
                            "boundsWidth": map(20, 0, monitors.monitorsBoundary.boundaryWidth, 0, this.obsBoundary.width),
                            "boundsHeight": map(20, 0, monitors.monitorsBoundary.boundaryHeight, 0, this.obsBoundary.height),
                        });
                    });
                }
            }

            updateOBS() {
                console.log("update obs", this.mainY + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, 0, this.obsBoundary.height);
                console.log("update obs map", map(this.mainY + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, 0, this.obsBoundary.height));
                console.log("boundary", this.boundary);
                console.log("obsBoundary", this.obsBoundary);   
                obs.call("SetSceneItemTransform", {
                    sceneName: "displayCapture", //this.sceneName,
                    sceneItemId: this.sourceId,
                    sceneItemTransform: {
                        "positionX": map(this.mainX + this.boundary.x, this.boundary.x, this.boundary.x + this.boundary.width, this.obsBoundary.x, this.obsBoundary.width + this.obsBoundary.x),
                        "positionY": map(this.mainY + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, + this.obsBoundary.y, this.obsBoundary.height + this.obsBoundary.y) ,
                        "boundsType": "OBS_BOUNDS_SCALE_INNER",
                        "boundsWidth": map(this.mainWidth, 0, this.boundary.width, 0, this.obsBoundary.width),
                        "boundsHeight": map(this.mainHeight, 0, this.boundary.height, 0, this.obsBoundary.height),
                    }
                });
                
                // console.log("update obs")   
                this.displays.forEach((display) => {
                    obs.call("SetSceneItemTransform", {
                        sceneName: "displayCapture", //this.sceneName,
                        sceneItemId: display.sceneItemId,
                        sceneItemTransform: {
                            "positionX": map(display.x + this.boundary.x, this.boundary.x, this.boundary.x + this.boundary.width, this.obsBoundary.x, this.obsBoundary.x + this.obsBoundary.width),
                            "positionY": map(display.y + this.boundary.y, this.boundary.y, this.boundary.y + this.boundary.height, this.obsBoundary.y, this.obsBoundary.y + this.obsBoundary.height),
                            "boundsType": "OBS_BOUNDS_SCALE_INNER",
                            "boundsWidth": map(display.width, 0, this.boundary.width, 0, this.obsBoundary.width),
                            "boundsHeight": map(display.height, 0, this.boundary.height, 0, this.obsBoundary.height),
                        }
                    })
                });
            }
        }
    </script>
    
    <script id="OBS Initialization">
        let mouseX,
        mouseY,
        mouseOverlayNames;

        let mainMonitor={};
        let otherMonitors = [];
 
        //set hotkey variables
        obs.on("Identified", async (data) => {
            await obs.call("GetInputSettings", { inputName: "ScreenShare_HotKey_Settings"})
            .then((result) => {
                const hotkeys = JSON.parse(`{${result.inputSettings.text}}`);
                console.log("Hotkeys from Settings Source:", hotkeys);
                followMouseAndZoom_HK = hotkeys.followMouseAndZoom_HK;
                followMouse_HK = hotkeys.followMouse_HK;
                fullScreen_HK = hotkeys.fullScreen_HK;
                toggleMouse_HK = hotkeys.toggleMouse_HK;
                toggleHotkey_HK = hotkeys.toggleHotkey_HK;
                zoomIn_HK = hotkeys.zoomIn_HK;
                zoomOut_HK = hotkeys.zoomOut_HK;
            });
            
            //set display capture source name
            displayCaptureScene = getComputedStyle(document.body).getPropertyValue('--display-capture-scene-name');
            displayCaptureSourceId = getComputedStyle(document.body).getPropertyValue('--display-capture-source-name');
                        
            obs.call("SetInputSettings", {
                inputName: 'keyHotkey',
                inputSettings: {
                    text: fullScreen_HK,
                }
            });

            setTimeout(async () => {
                //OBS adds css after page load, so wait a moment
                //get display info from obs css variables
                mainMonitor = getComputedStyle(document.body).getPropertyValue('--main-display-capture');
                //if tracking multiple monitors, get other monitor names
                if(getComputedStyle(document.body).getPropertyValue('--display-capture-source-name').trim() !== ''){
                    otherMonitors = JSON.parse(getComputedStyle(document.body).getPropertyValue('--display-capture-source-name'));
                }

                //if using mouse overlays, get overlay names
                mouseOverlayNames = JSON.parse(getComputedStyle(document.body).getPropertyValue('--overlay-names'));  
               
                //obsCollection.js functions 
                await getDisplayItems();
                const collectionStatus = await getOBScollection()
                
                // load p5.js library
                const loadP5 = new CustomEvent('loadP5Event')
                window.dispatchEvent(loadP5);
            }, 100);
            
            window.addEventListener('loadP5Event', (e) => {
                loadP5();
            }, false);
            
        });
        
        async function getSceneId(Scene, Source) {
            //create object of OBS collection(scenes and sources)
            return await obs.call("GetSceneItemId", { sceneName: Scene, sourceName: Source})
        }
        
        function loadP5(){
            loadScript("lib/p5.js");
        }
              
        function loadScript(src) {
            // Create a new script element
            var script = document.createElement('script');
            
            // Set the src attribute to the provided script source
            script.src = src;
            
            // Append the script element to the document's head
            // This will initiate the loading and execution of the script
            document.head.appendChild(script);
            
            // Optionally, you can add event listeners to handle load and error states
            script.onload = function() {
                console.log(`Script ${src} loaded successfully.`);
                // console.log("calling createShapes");    
                // createShapes();            
            };

            script.onerror = function() {
                console.error(`Error loading script ${src}.`);
            };
        }

        </script>

    <script id="obsInputRouter">
        //on obs text source settings change
        obs.on("InputSettingsChanged", async function (event) {
            // console.log(event);
            switch (event.inputName) {
                case 'MouseLocation':
                    //-- Get the current mouse position
                    const mousePosition = event.inputSettings.text.split(" ");
                    originalMouseX = Number(mousePosition[0]);      
                    originalMouseY = Number(mousePosition[1]);

                    mousePosX = mousePosition[0];
                    if (isMacOS()) {
                        // Perform macOS-specific mouse position adjustments
                        mousePosY = Math.round(map(mousePosition[1], monitors.mainY + monitors.mainHeight, monitors.mainY, 0, monitors.mainHeight))
                    } else {
                        mousePosY = Math.round(map(mousePosition[1], monitors.mainY, monitors.mainY + monitors.mainHeight, 0, monitors.mainHeight))
                    }
                    
                    //print mouse position to text source
                    obs.call("SetInputSettings", {
                        inputName: 'Mapped Mouse Location',
                        inputSettings: {
                            text: `${mousePosX} ${mousePosY}`,
                        }
                    });
                   break;
                    
                case 'keyHotkey':
                //console.log(event);
                switch (event.inputSettings.text) {
                    case ' ':
                        break;
                    // case followMouseAndZoom_HK: 
                    //     break;
                    case followMouse_HK:
                        break;
                    case fullScreen_HK:
                        // fullScreen();
                        break;
                    case toggleMouse_HK:
                        // toggleSource('scene|||Screen Share','Input Mouse Overlay')
                        break;
                    case toggleHotkey_HK:
                        // toggleSource('scene|||Screen Share','Input Hotkeys')
                        break;
                    case zoomIn_HK:
                        sketchMonitors.zoom += 0.2;
                        sketchMonitors.zoomUpdate();
                        break;
                    case zoomOut_HK:
                        if(sketchMonitors.zoom > 0.4){
                            sketchMonitors.zoom -= 0.2;
                            sketchMonitors.zoomUpdate();
                        }
                        // toggleSource('scene|||Screen Share','Input Hotkeys')
                        break;
                        default:
                            break;
                        }
                    }
                })

        function isMacOS() {
            return navigator.userAgent.indexOf('Mac') !== -1;
        }

        function setSourceTransform(sceneName, sourceId, transform) {
            obs.call("SetSceneItemTransform", {
                sceneName: sceneName,
                sceneItemId: sourceId,
                sceneItemTransform: transform
            });
        }
        </script>

</body>
</html>